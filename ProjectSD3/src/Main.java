import java.io.IOException;
import java.util.Locale;

/*
Генетический алгоритм

метод ветвей и границ рекурсией вызвать(неполный перебор), обрезание веток,если в какой то момент прохождения
пути становится больше чем в предыдущем полном решении, то идем к следующему варианту, если новый больше старого то обновляем,
как идея, если мы проходим допустим половину пути больше чем полвина предыдущего оптимального, выходим 70%



Реализовать приложение которое будет оболочкой для демонстрации, можно джитэйбл
Случайным образом или загрузить сохранить
Реализовано независимо алгоритмы для решения КОМИВОЯЖОРА
Привет вписать так чтобы приложение должно принимать некий класс который наследуется от интерфейса алгоритма
Это одна часть, а вторая имеет смысл провести и не только написать алгоритм разные коэффициенты от которых зависит результат
Для муравьиных как быстро феромоны исчезают какова вероятность не по оптим пути
Класс проблема в том что понятие локальных максимумов идем с точки по градиенту к максимуму
перебор нельзя но стратегии есть и не надо сделать сравнивать максимум
В нашем случае должно быть еще исследование презентация мы говорим такая стратегия  такие результаты исследование, результаты
Должны будем реализовать разных типов отдельно
Идеально было бы:
Кагл база данных можно будет найти данные чтобы их
Наш результат 80 процентов эффективности от лучших
Поискать статьи где эта задача решается сравнить результаты уже с теми алгоритмами которые уже есть и сравнить данные
В мае
Старт: с нас будут требовать чтобы нормально оформлено


пример задачи: надо обойти все пабы города в кратчайший на вход подается матрица в который расписаны все длины путей
1. сделать приложение для тупа джитэйбл куда закидываем матрицу и выводится ответ усе
алгоритм:
будем считать что изначально мы можем находиться в любой точке, тогда мы из нее
создать фрэйм мэин куда заносить саму таблицу с данными,
 */
public class Main {
    public static void main(String[] args) throws Exception{
        Locale.setDefault(Locale.ROOT);
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    new MainFrame().setVisible(true);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        });
    }
}
/*




пробовать большие графы проходить
чтобы это было наглядно
мы на плоскости случайным образом расставляем точки например от 0 до 100 количество точек нужно задавать
дальше строим матрицу смежности где у нас соответсвующее клетки это расстояния между вершинами
мы должны подводить под матрицу
задавать в форме параметры для алгоритма
потом сделать визуализацию
принцип работы алгоритма расписать в презентации

выступление 10-12 минут
презентация
расписываем как этот алгоритм работает
должен быть отчет до 10 страниц где мы пишем текст более подробно
через неделю примерно надо сделать 8числа в 6 часов скажет на лекции

 */